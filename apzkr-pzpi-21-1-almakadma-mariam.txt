Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
 
Факультет комп’ютерних наук  


Кафедра програмної інженерії
 
КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для контролю ефективності роботи працівників на підприємстві 

Студент гр. ПЗПІ-21-1         __________________ Алмакадма М.І.                               
(підпис)  
Керівник роботи                   _________________ доц. Лещинський В.О.  
(підпис)  
Роботу захищено «__»________2024 р. 
з оцінкою _________________________ 

Комісія:                                  _________________ доц. Лещинський В.О.  
(підпис)  
     ________________ доц. Лещинська І.О.
(підпис)  
  _________________ ст.викл. Сокорчук І.П. 
(підпис)  


Харків 2024 р.
     
Харківський національний університет радіоелектроніки  

Факультет комп’ютерних наук Кафедра програмної інженерії_____ Спеціальність 121 – Інженерія програмного забезпечення__________
Курс _____________3 _______________Семестр __________6______
Навчальна дисципліна Архітектура програмного забезпечення_____


ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ  
     
     
_____________________Алмакадма Маріам Iбрагімівни______________
1. Тема проєкту: «Програмна система для контролю ефективності роботи працівників на підприємстві»________            
2. Термін узгодження завдання курсової роботи «11» березня 2024 р.
3. Термін здачі студентом закінченої роботи «12» червня 2024 р.
4. Вихідні дані до проєкту (роботи): Програмна система  призначена для контролю ефективності роботи працівників на підприємстві, що вирішує актуальну проблему, має бути масштабованою, орієнтованою на користувача, захищеною та відповідати сучасним стандартам. Вона включає серверну, клієнтську частини, мобільний застосунок та IoT застосунок. Інтерфейс системи повинен бути реалізований українською та англійською мовами, а також підтримувати інтернаціоналізацію та локалізацію. Використовувати ОС Windows 11, СКБД PostgreSql, середовище розробки WebStorm.
5. Зміст пояснювальної записки (перелік питань, що належить розробити):   вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки.
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головних сторінок.




КАЛЕНДАРНИЙ ПЛАН
     
     
№Назва етапів курсової роботиТермін виконання
етапів роботиПримітки      1     Функціональна специфікація
     програмного проєкту14.04.24виконано      2     Проектування програмного
     проєкту27.04.24виконано      3     Кодування програмного проєкту25.05.24виконано      4     Оформлення пояснювальної
     записки07.06.24виконано      5     Захист курсової роботи12.06.24виконано           
     
     Дата видачі завдання «11» березня 2024 р.
     
     Керівник роботи                           __________доц. Лещинський В.О.  
      (підпис)  
     Завдання прийняв до виконання
     ст.гр. ПЗПІ-21-1                            _________              Алмакадма М.І.  
                            (підпис)
      



РЕФЕРАТ


     Пояснювальна записка до курсової роботи: 75 с., 36 рис., 5 джерел.
     КОНТРОЛЬ ЕФЕКТИВНОСТІ, КОМПАНІЯ, КЕРІВНИК, ПРАЦІВНИК, ВІДСТЕЖЕННЯ ЧАСУ РОБОТИ,  УПРАВЛІННЯ ЗАВДАННЯМИ, СИСТЕМА ВИНАГОРОД , ПРОГРАМНА СИСТЕМА.
     Об'єктом дослідження є розробка системи для контролю роботи на підприємстві, а саме відстеження показників, що впливають на працездатність працівників. Наприклад, години роботи, обсяг виконаних завдань та їх мотивація.
     Метою даної курсової роботи є розробка програмної системи, що спрямована на відстеження та підвищення ефективності роботи на підприємстві. Має можливість налаштовувати показники робочого дня, відповідно до якого всі працюють, повинна забезпечити перегляд та управління відділів та співробітників на підприємстві. Крім того, система спрямована на управління завданнями, а також застосування системи винагород для підтримання мотивації під час роботи.
     До методів розробки відносяться різні технології, наприклад, node.js для побудови серверної частини з використанням фреймворку Express.js, система керування базами даних PostgreSQL, технології React та мова програмування TypeScript використовуються для реалізації вебзастосунка, мобільний застосунок розроблено мовою програмування Kotlin.
     Результатом виконання курсової роботи є система для контролю ефективності роботи працівників на підприємстві. Система складається зі сервера, вебзастосунку та мобільного застосунку.
     
     

ЗМІСТ


      ВСТУП	7
      1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ	8
      1.1	Бізнес-вимоги	8
      1.1.1 Бізнес-можливості	8
      1.1.2 Бізнес цілі та критерії успіху	9
      1.1.3 Потреби клієнтів або ринку	10
      1.1.4 Бізнес ризики	11
      1.2 Концепція рішення	12
      1.2.1 Окреслення концепції	12
      1.2.2  Головна функціональність	13
      1.2.3 Припущення та залежність	13
      1.3 Рамки та обмеження проєкту	14
      1.3.1	Рамки первинного випуску	14
      1.3.2 Рамки наступних випусків	17
      1.3.3 Обмеження та винятки	17
      1.4 Бізнес-контекст	18
      4.1 Профілі зацікавлених сторін	18
      1.4.2 Пріоритети проєкту	19
      1.4.3 Робоче середовище	20
      2 ПОСТАНОВКА ЗАДАЧІ	22
      3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ	23
      3.1 Побудова ER-діаграми	23
      3.2 Побудова логічної моделі бази даних на основі ER-діаграми	24
      4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ	26
      4.1 Архітектура серверної частини	26
      4.3 Архітектура клієнтської частини	30
      4.4 Архітектура мобільної частини	34
      5 ОПИС ПРОГРАМНОЇ СИСТЕМИ	39
      5.1 Виклик і завантаження	39
      5.2 Призначення і логічна структура	39
      5.3 Опис програмної реалізації	40
      ВИСНОВКИ	48
      ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	49
      ДОДАТОК А Результати перевірки щодо академічної доброчесності	50
      ДОДАТОК Б Діаграма станів	51
      ДОДАТОК В Діаграми для клієнтської частини «PerformMentor»	53
      ДОДАТОК Г Програмний код серверної частини «PerformMentor»	56
      ДОДАТОК Д Програмний код клієнтської частини «PerformMentor»	64
      ДОДАТОК Б  Е Програмний код мобільної частини «PerformMentor»	70





ВСТУП


     Сучасний ринок характеризується жорсткою конкуренцією, що змушує підприємства шукати шляхи для оптимізації витрат та підвищення ефективності роботи. Одним з ключових факторів, що впливають на продуктивність, є ефективність роботи працівників. Традиційні методи контролю, такі як ручне ведення обліку та спостереження, часто неефективні, суб'єктивні та потребують багато часу. А неможливість автоматизації рутинних завдань з контролю та аналізу даних призводить до втрати часу та ресурсів.
     Для вирішення більшості з проблем, підприємства повинні звернути увагу на посилення мотивації та залучення працівників. Таким чином, прозора система оцінки результатів роботи може слугувати стимулом для кращої роботи. Регулярний зворотний зв'язок та чітка постановка завдань будуть мотивувати працівників до саморозвитку.
     Розглядаючи тенденції сьогодення, можемо побачити ріст популярності віддаленої роботи та гнучкого графіка, який потребує постійного використання методів контролю та оцінки результатів праці, що допоможуть не тільки у моніторингу та координації роботи віддалених працівників, а й у забезпеченні командної роботи та співпраці.
     Одним із найголовніших факторів ефективності є як ментальне, так і фізичне здоров’я працівників. Перевантаження та стреси на роботі можуть негативно впливати на ці фактори. Тому, підприємства повинні своєчасно виявити ознаки перевантаження та стресу, а також їх запобігти.
     Метою даної курсової роботи є проєктування системи для контролю ефективності роботи працівників на підприємстві. Система орієнтується на використанні системи винагород для підвищення мотивації серед робітників, для роботи з керівниками та працівниками. А також на управління завдань.
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
     1.1 Бізнес-вимоги
     1.1.1 Бізнес-можливості
     
     
     Система контролю ефективності роботи працівників спрямована на глобальний ринок. Вона може бути корисна для користувачів з різних країн, які потребують програмне забезпечення для систематизації роботи на підприємстві.
   Розглянемо аналоги на ринку. «Clockify» - програмне забезпечення для відстеження часу, яке допомагає керувати часом, який витрачають на проєкти, завдання чи роботу. Пропонує низку функцій для обліку часу, звітування та керування людьми, з якими працюють. Попри низку дійсно корисного функціоналу, відсутні певні можливості, що є важливим для роботи на підприємстві. Таким чином, «PerformMentor» має переваги у призначені завдання окремим користувачам або командам, та у системі визнання, щоб мотивувати працівників та підкреслювати їх досягнення.  
     Розглянемо ще один аналог - «Time Doctor». Програмне забезпечення для відстеження часу, розроблене для віддалених і офісних команд. Основний функціонал включає відстеження використання Інтернету та додатків, відстеження відвідуваності та управління завданнями. Однак при перегляді відгуків користувачів, можемо зробити висновки, що система сповільнює робочі ноутбуки або комп'ютери, часто відбувається збій роботи системи та проблеми із синхронізацією даних між комп’ютером і мобільними пристроями.
     «PerformMentor» є більш розширеним застосунком та передбачає можливість інтеграції з календарем, щоб автоматично додавати завдання користувачам. 
     Система «PerformMentor» надалі матиме багаторівневу модель ціноутворення. Безкоштовний пакет пропонуватиме обмежену кількість функцій, наприклад, відстеження часу, управління завданнями та базові звіти. Він буде ідеально підходити для малих команд розміром до 15 працівників та приватних підприємців, які хочуть протестувати систему перед придбанням платного пакета.
     Платний пакет для малих команд пропонує більше функцій, ніж безкоштовний пакет, такі як співпраця над завданнями, розширені звіти та функціонал у мобільних застосунках. Він буде ідеально підходити для малих команд, які потребують більш гнучких можливостей.
     Платний пакет для великих команд, розміром до 200 керівників та працівників, буде пропонувати всі функції платних пакетів для малих команд, а також додаткові функції, такі як управління користувачами, налаштування системи та використання розумного пристрою (IoT застосунок). Він буде ідеально підходити для великих команд, які потребують комплексного рішення для відстеження продуктивності.
     Розглянемо ціноутворення без врахування зарплатні розробника. Консультація з юридичних питань – 20 тисяч гривень, ліцензія програмного забезпечення та оплата за розміщення сайту – 7 тисяч гривень. Разом 27 тисяч гривень за місяць. Якщо ми хочемо заробити вдвічі більше за витрати, то з вартістю 700 гривень для платного пакета малих команд, необхідно мати принаймні 110 компаній з таким типом підписки. Для платного пакета великих компаній вартість – 1300 гривень, а кількість компаній – 60.
     
     
     1.1.2 Бізнес цілі та критерії успіху
     	
     
     БЦ-1: Допомогти підприємствам оптимізувати робочі процеси, скоротити час, витрачений на рутинні завдання, та підвищити загальну продуктивність праці.
     БЦ -2: Сприяти координації дій, обміну інформацією та спільній роботі над проєктами.
     БЦ-3: Запропонувати підприємствам інноваційне та ефективне рішення для управління персоналом, яке допоможе їм випередити конкурентів.
     БЦ-4: Забезпечити фінансову стійкість та прибутковість продукту.
     КУ-1: Після 5 місяців кількість користувачів, які звітують про скорочення часу, витраченого на рутинні завдання, перевищує 25%. Збільшення обсягів виконаної роботи на 20%.
     КУ-2: Після 6 місяців відбувається збільшення кількості успішно виконаних спільних проєктів на 28%. Зменшення часу, необхідного для завершення спільних проєктів, на 25%. Покращення рівня задоволеності співпрацею в команді на 40%, згідно з опитуваннями. 
     КУ-3: На перших етапах впровадження системи, понад 65% відгуків клієнтів будуть позитивними. Зростання впізнаваності системи серед малих та середніх підприємств.
     КУ-4: Досягнення точки беззбитковості протягом 10 місяців. Збільшення чистого прибутку на 1,7% протягом року.
     
     
     1.1.3 Потреби клієнтів або ринку
     
     
     Відповідно до аналізу потреб користувачів, можемо визначити, що існує низка потреб для підтримання та росту ефективності на підприємстві. Оптимізація робочих процесів мала б можливість скоротити час, який витрачають на рутинні завдання. 
     На роботі працівник повинен розуміти оцінку своїх результатів, мати регулярний зворотний зв'язок та  чітку постанову роботи над завданнями. Адже найчастіше плутанина з термінами, обсягом та умов виконання завдань стають фактором зниження продуктивності та збільшення витраченого часу.
     Спираючись на тенденцію росту кількості охочих працювати на віддаленій роботі, робимо висновок, що потрібна система для роботи в команді, для забезпечення контролю та оцінки віддалених працівників.
     Підприємство повинно пам'ятати, що здоров'я працівників є важливою складовою для будь-якого процесу. Тож повинна бути змогу виявляти ознаки перевантаження та стресу на робочому місці. 
     Розглядаючи ринок, можемо визначити, що підприємства всіх розмірів, у широкому спектрі галузей потребують контроль ефективності роботи. 
     
     
     1.1.4 Бізнес ризики
     
     
     Одним із ризиків є конкуренція на ринку. «PerformMentor»  змагатиметься з іншими продуктами, що вже мають певну частку на ринку. Конкурентна боротьба може вплинути на здатність залучати та утримувати користувачів.
     Ще одним ризик пов'язаний із працівниками на підприємстві. Недостатня зацікавленість працівників в користуванні системою може негативно вплинути на її прийняття та ефективність.  А користувачі, які не мають достатнього досвіду роботи з подібними системами, можуть мати  труднощі при їх налаштуванні та використанні. Для подолання цієї проблеми, необхідно розробити ефективну програму навчання. Запропонувати гнучкі налаштування та можливості для адаптації системи до потреб користувачів.
     Через те, що розробка та підтримка системи контролю ефективності роботи працівників вимагає постійного оновлення та адаптації до змін у технологічному середовищі. Технічні неполадки чи безпекові загрози також можуть стати ризиками для стабільності системи.
     Юридичні ризики також важливо зазначити. Зміни в законодавстві або недотримання контрактних зобов'язань однією зі сторін. Для уникнення цього, необхідно отримувати юридичні консультації. 
     У разі залежності від інших компаній чи партнерів для певних аспектів функціонування системи, можуть виникнути ризики в разі невдалої співпраці або змін в умовах партнерства.
     Для досягнення поставлених бізнес-цілей, необхідно інвестувати в розробку, обладнання, ліцензій та маркетинг системи. Фінансові труднощі можуть призвести до нездатності досягнути запланованих результатів.
     
     
          1.2 Концепція рішення
          1.2.1 Окреслення концепції
     
     
     Платформа контролю ефективності роботи працівників, яка спрямована на підвищення продуктивності та мотивації персоналу на підприємстві пропонує комплексний підхід до управління завданнями, постановки та відстеження цілей, аналітики та мотивації працівників.
     Програмний продукт «PerformMentor» пропонує користувачам можливість управління завданнями та коментарями до нього, управління кадрами, витраченого часу на роботу та використання системи винагород.
     Система корисна для компаній різного розміру, керівників, які хочуть контролювати роботу, та працівників. Продукт орієнтований не тільки на контроль виконання завдання, витраченого часу, а й на здоров'я працівників.  
     «PerformMentor» використовує комплексний підхід та призначений, щоб допомогти користувачам бути більш продуктивними та досягати своїх цілей.
     
     
     1.2.2  Головна функціональність
     
     
     ГФ-1: Можливість створювати завдання з детальними описами, термінами виконання та пріоритетами.
     ГФ-2: Призначення завдань окремим користувачам або командам.
     ГФ -3: Спільна робота над завданнями з можливістю додавати коментарі.
     ГФ-4: Візуалізація прогресу виконання завдань в компанії.
     ГФ-5: Створення системи балів та нагород для стимулювання мотивації.
     ГФ-6: Отримання визнання за досягнення та внесок у роботу.
     ГФ-7: Надання та отримування винагороди за певну кількість балів.
     ГФ-8: Налаштування робочих годин та днів на підприємстві.
     ГФ-9: Реєстрація проведеного часу на роботі та понаднормової праці.
     ГФ-10: Налаштування структури компанії, а саме відділи.
     ГФ-11: Керування та управління даними робітників компанії.
     ГФ-12: Використання багатомовного інтерфейсу.
     
     
     1.2.3 Припущення та залежність
   
   
     П-1: Користувачі будуть мати доступ до Інтернету для використання системи «PerformMentor».
     П-2: Користувачі мають пристрої, такі як комп'ютери, смартфони або планшети, для доступу до системи. Використання системи може бути неефективним на застарілих або несумісних пристроях.
     П-3: Користувачі відповідають системним вимогам «PerformMentor», включаючи встановлення додатків або дозволів для коректної роботи.
     З-1: Система «PerformMentor» буде доступна декількома мовами.
     З-2: Система «PerformMentor» у платному пакеті буде використовувати безконтактні карти (RFID-карти). Ця залежність є важливою для відстеження роботи користувачів.
     З-3: Мобільний застосунок повинен мати зручний інтерфейс, не займати багато місця.
     
     
     1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску
     
     
     Серверна частина повинна містити:
* реєстрація компанії, вхід в обліковий запис, оновлення даних;
* створення відділів, перегляд та оновлення даних про них;
* реєстрація робітників в компанії, пошук за прізвищем та фільтрація за відділом, можливість підвищення або пониження у посаді;
* створення та оновлення завдань, призначення виконавців, перегляд завдань;
* перегляд назначених завдань;
* спільна робота над завданнями з можливістю додавати, переглядати та видаляти коментарі.
* перегляд статистики та прогрес виконання завдань на підприємстві;
* створення системи балів та нагород для стимулювання мотивації;
* можливість отримувати досягнення за певний внесок роботу та отримувати бали;
* можливість викупати нагороди за бали;
* налаштування робочих годин на підприємстві;
* реєстрація проведеного часу на роботі;
* реєстрація понаднормової роботи;
* створення резервних копій;
* шифрування даних для збереження конфіденційних даних за допомогою bcrypt;
* використання валідації даних та параметризованих запитів SQL, для запобігання атак SQL-ін'єкції та іншим форм вразливостей.
     IoT частина повинна містити:
* використання безконтактних карток для відстеження взаємодії між працівниками;
* збір, аналіз та відправлення даних;
* захист від зовнішнього втручання.
Клієнтська частина повинна містити:
* авторизація відповідно до ролі, а саме керівник або працівник;
* оновлення пароля;
* керівник має можливість створювати завдання з детальними описами, термінами виконання та пріоритетами.
* керівник або працівник можуть спільно працювати над завданнями з можливістю переглядати, додавати та видаляти коментарі;
* керівник або працівник мають можливість отримувати визнання за досягнення та внесок у роботу та переглядати їх;
* керівник може призначати досягнення;
* керівник може призначати нагороди за наявності балів на балансі;
* керівник або працівник можуть отримати додаткові бали на баланс;
* керівник або працівник переглядати нагороди;
* керівник або працівник можуть забрати нагороду;
* реєстрація компанії;
* авторизація в акаунт компанії;
* налаштування особистого профілю компанії;
* налаштування годин роботи компанії;
* створення облікового запису для користувачів;
* перегляд робітників компанії, пошук за прізвищем та фільтрація за відділом;
* видалення працівників;
* перегляд, оновлення даних та створення нового відділу;
* компанія може переглядати статистику та прогрес виконання завдань на підприємстві;
* компанія повинна мати можливість додавати нові винагороди;
* перегляд інформації щодо робітників та їх нагороди;
* перегляд інформації щодо понаднормової праці;
* валідація даних;
* підтримка інтернаціоналізації та локалізації українською та англійською мовами;
     Мобільна частина повинна містити: 
* авторизація в профілі робітника, валідація даних;
* перегляд нагород;
* можливість забрати нагороду;
* реєстрація початку та кінця робочого дня;
* реєстрація початку та кінця перерви;
* перегляд інформації щодо тривалості робочих днів;
* підтримка інтернаціоналізації та локалізації українською та англійською мовами;


     1.3.2 Рамки наступних випусків
     
     
     Серверна частина може містити:
* аналіз даних щодо продуктивності користувачів під час роботи;
* ідентифікація областей, які потребують покращення;
* виявлення тенденцій та закономірностей у продуктивності з часом.
IoT частина може містити:
* сканер штрих-кодів, щоб працівники могли швидко сканувати товари або інші предмети, пов'язані з їхньою роботою;
Клієнтська  частина може містити:
* карту знаходження робітників у робочих приміщеннях;
* можливість обирати підписку;
* відображення статистику взаємодії користувачів та їх ефективності, що допоможе надалі планувати виконання проєктів.
Мобільна частина може містити: 
* інтеграція управління завдань разом із календарем;
* сповіщення про зустрічі;


     1.3.3 Обмеження та винятки
     
     
     О-1: Застосунок не можуть використовувати особи віком молодше 16 років.
     О -2: Особи віком до 18 років не можуть працювати повний робочий день.
     О -3: Застосунок працює тільки за умови підключення до мережі Інтернет.
     О -4: Доступ до інформації має тільки авторизований користувач.
     О-5: IoT застосунок не можуть використовувати компанії, що не купили платну підписку. 
     В-1: Програма може бути несумісною з усіма пристроями чи операційними системами. Перед завантаженням і встановленням програми користувачі повинні перевірити системні вимоги.
     В-2: У разі необхідності проведення технічних робіт на сайті, можливо тимчасове обмеження доступу до деяких функцій або всієї платформи. Про це буде своєчасно повідомлено користувачів.
     В-3: IoT застосунок може бути не точним у випадках пошкодження карти або міток зчитування. 
     
     
     1.4 Бізнес-контекст
     4.1 Профілі зацікавлених сторін
     
     
     Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторонаГоловна цінністьСтавленняГоловний інтересОбмеження      КомпаніяПідвищення ефективності роботи;
заохочує працівників.Очікують, що система буде відповідати їх потребам.Отримати максимальну віддачу від інвестицій у систему.Бюджет 1300 гривень; час; ресурси.            
      
      
     Продовження таблиці 1.1
КерівникДелегування, відстеження та розв'язання проблем продуктивності.Очікує, що система буде зручною; 
Покращити результати роботи своєї команди.Час; ресурси.      Звичайний працівникЧітке розуміння завдань, відстеження прогресу.Очікує, що система буде зручною.Балансу між роботою та особистим життям.Час; ресурси.      Команда розробниківЗбільшення доходів компаніїСильна мотивація щодо всіх аспектів випускуРозробка нових функцій; відгуки користувачівБюджет: 15 тис дол. США; час;
технологічні можливості           
     
     1.4.2 Пріоритети проєкту
     
     
     Таблиця 1.2 – Пріоритети проєкту
ПоказникВиконання (етапи)Обмеження (граничні значення)Ступінь свободи (допустимий діапазон)      План робітВипуск 1.0 стане доступним до 25.05.2024
випуск 1.1 – до 25.10.2024            
      
     Продовження таблиці 1.2
Функціональність80% функцій із високим пріоритетом мають бути включені до випуску 1.0      ЯкістьУ випуску 1.0 повинні пройти 100% тестів
У випуску 1.1 – 90% - 95%       ПерсоналМаксимальний розмір команд: 1      ЦінаДопустимо
перевищити бюджет
на 17% без перегляду робіт           

     1.4.3 Робоче середовище
     
     
     Система контролю ефективності роботи на підприємстві «PerformMentor» охоплює такі компоненти: серверна частина, клієнтська частина, мобільний програмний застосунок та IoT застосунок.
     Для роботи з даними було обрано СУБД PostgreSQL з широким спектром функцій, включаючи підтримку відновлення, масштабування, безпеки та ін [1]. 
     Для обробки та управління серверною частиною було обрано Express.js, який є фреймворком, побудованим на платформі node.js. Такий метод забезпечить швидку, гнучку та масштабовану розробку серверу [2].
     Для реалізації клієнтської частини буде використано TypeScript, бібліотеку React та CSS для стилізації [3]. 
     Для створення програмної частини IoT (Internet of Things) застосунку, передбачається використання Arduino IDE та бібліотек, мова програмування Python, а також можливість інтегрувати мережеві стеки та протоколи, такі як MQTT, CoAP, HTTP, та WebSocket. Ці протоколи грають важливу роль у забезпеченні ефективної комунікації між IoT-пристроями та хмарами, дозволяючи передавати дані та керувати пристроями надійно та забезпечувати безпеку зв'язку.
     Мобільний застосунок розробляється з використанням Android Studio SDK, яке є офіційним інтегрованим середовищем розробки для платформи Android. Також застосунок розробляється з використанням мови програмування Kotlin, що дозволяє створити надійний та ефективний мобільний інтерфейс.
     Для забезпечення оптимального функціонування системи «PerformMentor» і задоволення потреб користувачів, визначимо, що система повинна мати регулярні резервні копії для уникнення втрати даних, система має бути доступною для користувачів з усього світу 24/7, оптимізація завантаження сервера для реагування на зростання кількості користувачів. А також повинні бути заходи для запобігання несанкціонованому доступу до даних.









2 ПОСТАНОВКА ЗАДАЧІ
     
     
     Після аналізу предметної області, визначаємо, що під час курсової роботи треба створити програмну систему для контролю ефективності роботи працівників на підприємстві. База даних повинна містити інформацію про компанії, користувачів, досягнення, нагороди, завдання, коментарі, відділи, години роботи та налаштування годин робот в компаніях.
     Потрібно реалізувати функціонал для компанії:
* реєстрація компанії, вхід в обліковий запис, оновлення даних;
* створення відділів, перегляд та оновлення даних про них;
* реєстрація робітників в компанії, можливість підвищення або пониження у посаді;
* перегляд статистики та прогрес виконання завдань на підприємстві;
* налаштування робочих годин на підприємстві.
Потрібно реалізувати функціонал для керівника та працівника:
* створення та оновлення завдань, призначення виконавців, перегляд завдань;
* перегляд назначених завдань;
* спільна робота над завданнями з можливістю додавати, переглядати та видаляти коментарі.
* створення системи балів та нагород для стимулювання мотивації;
* можливість отримувати досягнення за певний внесок роботу та отримувати бали;
* можливість викупати нагороди за бали;
* реєстрація проведеного та понаднормового часу на роботі;
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
     3.1 Побудова ER-діаграми
     
     
     Для проєктування бази даних було розроблено ER-модель даних діаграму за нотацією Чена, що знаходиться на рисунку 3.1. 

Рисунок 3.1 – ER-діаграма за нотацією Чена

     Сутність Компанія містить інформацію про компанії або підприємства системи. Має зв’язок «один-до-багатьох» із сутністю Налаштування робочого часу, зв’язок «один-до-багатьох» із сутністю Нагорода, зв’язок «один-до-багатьох» із сутністю Відділ.
     Сутність Налаштування робочого часу відповідає за вміст інформації щодо тривалості робочих годин та днів у компанії, пов’язана із сутністю Компанія.
     Сутність Відділ відповідає за вміст інформації щодо відділу компанії, пов’язана із сутністю Компанія, та має зв’язок «один-до-багатьох» із сутністю Користувач.
     Сутність Користувач містить інформацію щодо користувачів системи, наприклад посада, пов’язана із сутністю відділ, має зв’язок «багато-до-багатьох» із сутністю Нагорода, зв’язок «багато-до-багатьох» із сутністю Завдання в ролі виконавця завдання та «один-до-багатьох» в ролі власника завдання,  зв’язок «один-до-багатьох» із сутністю Досягнення, зв’язок «один-до-багатьох» із сутністю Робочі години, зв’язок «один-до-багатьох» із сутністю Коментарі.
     Сутність Нагорода містить інформацію про нагороду, яку створила компанія, пов’язана із сутністю Компанія та зв’язок «багато-до-багатьох» із сутністю Користувач.
     Сутність Досягнення містить інформацію про назначене досягнення до користувача, пов’язана із сутністю Користувач.
     Сутність Робочі години містить інформацію щодо початку, кінця перерви та робочого дня, тривалість робочого дня та тривалість понаднормової праці.
     Сутність Коментарі містить інформацію щодо створених коментарів і пов’язана із сутністю Користувач та Завдання.
     Сутність Завдання містить інформацію щодо завдання, має в’язок «багато-до-багатьох» із сутністю Користувач, що відображає виконання завдання, зв’язок «один-до-багатьох» для відображення власника завдання, та зв’язок «один-до-багатьох» із сутністю Коментарі. 
     
     
     3.2 Побудова логічної моделі бази даних на основі ER-діаграми
     
     
     Усунимо зв’язки «багато-до-багатьох» між Користувачем та Нагородою, користувачем та Завданням, для нормалізації бази даних. Для цього створюємо Виконавці_завдання та Нагороди_користувача (див. рис. 3.2). 

Рисунок 3.2 – Схема бази даних «PerfomMentor»

     Логічна модель бази даних представлена:
* Досягнення (achievements);
* Коментарі (comments);
* Компанія (companies);
* Відділ (departments);
* Нагорода (rewards);
* Виконавці_завдання (task_executors);
* Завдання (tasks);
* Користувачі (users);
* Нагороди_користувача (users_reward);
* Робочі години (work_hours);
* Налаштування робочого часу (work_hours_settings);

     
     
4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
     4.1 Архітектура серверної частини
      
     
     Система розрахована на три типи користувачів, а саме компанія, керівник відділу та звичайний працівник.
     Розглянемо інформаційні потреби компанії через діаграму прецедентів, що наведено на рисунку 4.1. Перш за все, компанія може зареєструватись у системі та робити вхід в профіль. Компанія може створити нові відділи та редагувати їх.

     Рисунок 4.1 – Діаграма прецедентів  з актором компанія
     
     Компанія додає своїх працівників, при реєстрації створюється пошта, на основі прізвища та ім’я,  та пароль. Перегляд працівників та видалення, за потреби. 
     Можливо переглядати кількість відкритих, в процесі та завершених завдань з відсотковим відношенням. 
     Для уникнення понаднормової роботи, компанії визначають час, кількість робочих днів, та допустиму норму понаднормової роботи. 
     Розглянемо інформаційні потреби керівників відділів через діаграму прецедентів, що наведено на рисунку 4.2. Керівник може війти у свій профіль, змінити пароль, бо спочатку він генерується автоматично при створені профілі.
     

Рисунок 4.2 – Діаграма прецедентів  з актором керівник

     Керівник має можливість реєструвати початок, кінець робочого дня, а також початок та кінець перерви. На основі даних налаштувань робочих годин в компанії розраховується понаднормова праця. Можливо переглядати дані про роботу усіх працівників відділу. 
     Керівник має право призначати досягнення працівникам за якийсь виконаний проєкт або інші види активності, кожне досягнення дорівнює певним балам, які ідуть на рахунок кожного користувача. Керівник має право призначити нагороду працівникам, яка потребує певної кількості балів на рахунку, а також самостійно отримати нагороду та викупити її за бали на рахунку. Керівник може створювати завдання, змінювати їх, призначати працівників, які повинні будуть виконувати їх, створювати коментарі та переглядати усі коментарі до завдання.  
     Розглянемо інформаційні потреби працівника через діаграму прецедентів, що наведено на рисунку 4.3. Працівник, як і керівник, може зайти у свій профіль, змінити пароль, оновити особисті дані. 
     Працівник може переглядати завдання, що їм назначені, оновлювати, переглядати коментарі до завдання та писати власні коментарі. Працівник може отримати досягнення, таким чином його баланс балів збільшується, отримати нагороду, та викупити її, а саме заплатити балами, нагорода може бути як фізична, так і віртуальна. 

Рисунок 4.3 – Діаграма прецедентів  з актором працівник

     Можливо реєструвати проведений час на роботі, а саме початок, кінець та перерва. При роботі більше ніж нормований графік, визначаються години понаднормової праці. 
     Математичні дії на сервері представлені у розрахунку понаднормової праці, а саме розрахунок тривалості дня без використання перерви мінус зазначені години роботи у налаштуваннях, які були помножені на 60. Також система бонусів використовує додавання до балансу кількість бонусів, що зазначені у досягненні, та при отриманні нагороди віднімаються бали.
     Для роботи з базами даних було обрано СУБД PostgreSQL. Для розробки сервера обрано WebStorm. Для підключення бази даних до сервера було використано плагін "Database Tools and SQL," після чого в налаштуваннях плагіну додала нове з'єднання з PostgreSQL, вказавши параметри підключення, такі як URL бази даних, ім'я користувача та пароль.
     Для роботи з сервером було використано різні технології. Express.js – фреймворк для побудови застосунків на Node.js, що дозволяє швидко розробляти маршрути, обробляти запити. Sequelize – це ORM (Object-Relational Mapping), який дозволяє взаємодіяти з базою даних SQL за допомогою JavaScript
     Для кращого розуміння сервера розробили діаграму розгортання, що є важливим інструментом для візуалізації фізичної архітектури системи (див. рис. 4.4.). За допомогою діаграми розгортання визначили розташування та зв'язки між компонентами, що дозволяє проєктувати, аналізувати та оптимізувати фізичну структуру системи, а також спрощує розуміння взаємодії між компонентами.

     Рисунок 4.4 – Діаграма розгортання
     
     Ще одну діаграму, яку було розроблено – діаграма станів для компанії, керівника та працівника (див. додаток Б, рис. Б.1 – Б.3). Ця діаграма дозволяє показати можливі стани системи, події, які можуть спричинити переходи між станами, і дії, які відбуваються в кожному стані.
     За структурою можна виділити model, controllers, routers та services. В моделях описуються структури даних та відображають таблиці бази даних. Контролери відповідають за обробку запитів та виклик відповідних методів моделей. Вони приймають дані з маршрутів, викликають відповідні методи моделей та повертають відповідь клієнту. Роутери відповідають за визначення маршрутів та пов'язані з ними контролери. Вони розподіляють запити від клієнтів на відповідні контролери для обробки. Сервіси відповідають за виконання основних операцій, взаємодіючи з моделями бази даних. Middleware - це функції, які обробляють запити перед тим, як вони дійдуть до маршрутів. 
     У даному проєкті REST використовується для реалізації вебсервера з рядом API-маршрутів, які відповідають стандартним операціям створення, читання, оновлення, видалення. Кожен маршрут визначений за допомогою Express.js та відповідає за конкретний ресурс чи функціональність, а HTTP методи (POST, GET, PUT, DELETE) визначають тип взаємодії з цими ресурсами. Кількість кінцевих точок – 59.
     Перевірка роботи сервера проходила через програмне забезпечення «Postman». Сервер отримував та передавав дані, як і було очікувалось. Тестування також включало аналіз реакції сервера на невірні запити або некоректно введені дані, а також перевірку наявності відповідей з правильними HTTP статус-кодами. Це дозволило впевнитися, що сервер коректно обробляє навантаження та забезпечує правильну відповідь на кожний запит від клієнта, підтримуючи стандарти RESTful архітектури.
     Приклад кодової частини наведено у додатку Г.
     
     
     4.3 Архітектура клієнтської частини
     
     
     Клієнтська частина розрахована на 3 користувача: компанія, керівник відділу та працівник.
     З діаграми на рисунку В.1 у додатку В бачимо, що компанія може зареєструватись та війти у свій профіль. Можливе оновлення налаштувань робочих годин та даних компанії, таких як назва та адреса. Компанія може переглядати відділи які вже створені, редагувати їх та додати новий. Є можливість створення нагород та перегляд працівників або керівників, яким вони були призначені. Для перегляду статистики завдань, існує кругова діаграма, що відображає кількість завдань певного типу, наприклад, відкрито, в процесі, закрито. Компанія може переглядати, редагувати працівників та керівників, що працюють у них, а фільтрація за відділом та пошук за прізвищем полегшують навігацію між ними. Можливо зареєструвати нового працівника.
     З діаграми на рисунку В.2 у додатку В бачимо, що керівник може зайти у свій профіль, змінити пароль, переглядати свої досягнення, при назначені досягнення, керівник отримує бали, що відображається на балансі, отримати нагороду, і тоді бали списуються з балансу, а потім керівник може її забрати. Є можливість переглядати завдання, оновлювати їх та переглядати, створити, видаляти коментарі до них. Керівник може  створити завдання та призначити їх іншим співробітникам відділу. 
     З діаграми на рисунку В.3 у додатку В бачимо, що працівник може зайти у свій профіль, змінити пароль, переглядати свої досягнення, отримати нагороду. До кожного назначеного завдання можна переглянути, створити та видалити коментарі. 
      Для розробки клієнтської частини системи «PerformMentor» було використано мову програмування TypeScript з використанням бібліотеки React та CSS для стилізації.
     Для реалізації локалізації інтерфейсу було використано бібліотеку react-intl, що допомагає впроваджувати багатомовний інтерфейс та забезпечує зручний механізм перекладу текстових рядків.
     Для реалізації навігації на сайті використано бібліотеку react-router-dom, яка надає інструменти для створення реактивної навігації та управління маршрутами вебзастосунка.
       Для виконання асинхронних запитів на сервер використано бібліотеку axios, яка забезпечує інтерфейс для взаємодії з HTTP-запитами та дозволяє легко обробляти відповіді від сервера.
     Бібліотека react-icons/fa використана для додавання іконок FontAwesome у компоненти інтерфейсу, що забезпечує візуальне покращення та підвищує зручність використання застосунку.
     Бібліотека react-chartjs-2 використовується для інтеграції Chart.js з React, що дозволяє легко створювати інтерактивні графіки та діаграми, надаючи користувачам можливість візуалізувати дані у зручному форматі.
     Бібліотека react-datepicker застосована для реалізації компонента вибору дат, що забезпечує зручний інтерфейс для введення та вибору дат користувачами, інтегруючись з інтерфейсом застосунку.
     На рисунку 4.5 зображено діаграму пакетів для візуалізації використаних пакетів. 
     
     Рисунок 4.5 – Діаграма пакетів для клієнтської частини системи «PerformMentor»
     
     Розроблено клієнтську частину за допомогою Feature-Sliced архітектури. Вона визначає побудову проєкту за допомогою шарів. Шари включають зрізи, які включають сегменти. Шари – це каталоги верхнього рівня застосунку. 
     У проєкті визначено 8 шарів: app, components, context, features, hooks, interfaces, pages, та styles. Шар app містить відповідальність за ініціалізацію та конфігурацію. Шар components містить компоненти, які можуть бути використані на різних сторінках або в різних функціональних частинах застосунку декілька разів. Шар context містить контексти, які використовуються для керування станом застосунку та передачі даних між компонентами. Шар features відповідає за функціонал застосунку. Шар hooks відповідає за об’єкти хуків, які дозволяють компонентам отримувати доступ до станів системи. Шар interfaces визначає інтерфейси моделей, які використовуються для обміну даними з сервером та їхнього представлення на сторінках. Шар pages містить сторінки сайту.  Шар styles містить стиль сторінок.
     Для більш детального розуміння архітектури системи було розроблено діаграму компонентів (див. додаток В, рис. В.4).
     Розглянемо взаємодію між користувачами та клієнтською частиною на рисунках В.5 та В.6 з додатка В. 
     Керівник та працівник починають працювати з системою при вводі даних, коли входять в систему. Працівник має менше можливостей у порівнянні з керівником. Тому характерні можливості це перегляд досягнень, перегляд власних нагород та можливість забрати нагороди, оновити пароль. При перегляді назначених завдань, працівник або керівник можуть оновити завдання, переглянути виконавців, переглянути коментарі, та додати або видалити їх.
     У керівника є ще можливість переглядати працівників та керівників відділу, до якого він належить. Тоді керівник може призначити досягнення, що додають бали до балансу, та призначати нагороди, за які треба платити з балансу. Також створити завдання та призначити виконавців зі співробітників відділу (див. рис. В.5).
     Якщо розглядати компанію, то її взаємодія зі системою починається при вводі даних під час реєстрації або входу в профіль. Компанія може редагувати власну інформацію, переглядати відділи, редагувати їх та створити новий. При перегляді нагород, компанія також може створити нову, визначивши назву, опис, кількість балів необхідних для її отримання. При перегляді працівників та керівників можливо здійснити пошук за прізвищем та фільтрувати за назвою відділу. Можливо оновити їх персональні дані та змінити посаду, наприклад, підвищити до статусу одного із керівника відділу. При реєстрації працівника, компанія вводить дані та відділ, після чого отримує пароль та пошту користувача. Для підвищення продуктивності компанія також бачить статистику завдань в компанії  та може переглядати нагороди працівників (див. рис. В.6).
     Приклад кодової частини наведено у додатку Д.
     
     
     4.4 Архітектура мобільної частини
     
     
     Користувачами мобільного застосунку є працівники або керівники компанії, що зареєстрована в системі «PerformMentor». Функціонал для користувачів є однаковим. Спочатку треба авторизуватися, для цього потрібно ввести електрону пошту та пароль. 
     За наявності нагород у користувача, він може їх переглядати. Якщо користувач ще не забрав нагороду, то має можливість це зробити. 
     Реєстрація годин роботи працівника відбувається за допомогою мобільного застосунку, а саме реєстрація початку робочого дня, початку перерви, кінець перерви та робочого дня. Користувач може переглянути інформацію відповідно до днів, коли працював, а також загальну тривалість робочого дня. Таким чином можливо відстежити ефективність роботи (див. рис. 4.6). 

Рисунок 4.6 – Діаграма прецедентів  з актором користувач

     Для розробки мобільного застосунку було обрано мову програмування Kotlin. В ролі середовища розробки використовується Android Studio, яке є офіційним інтегрованим середовищем розробки для платформи Android. 
     Для розширення можливостей Kotlin в Android використовується пакет core-ktx, який надає ефективний спосіб взаємодії з різними компонентами Android. Наприклад, дозволяє писати чистий, компактний код, що прискорює процес розробки та зменшує ймовірність виникнення помилок.
     Використовуємо пакет appcompat, що допомагає підтримувати старі версій Android та забезпечення сумісності з сучасними функціями. Також він забезпечує однорідний інтерфейс для користувачів на різних версіях Android, що полегшує розробку та покращує сприйняття користувачів.
     Пакет material використовується для створення інтерфейсів користувача з використанням компонентів Material Design. Таким чином, це спрощує створення привабливих і сучасних інтерфейсів, забезпечуючи однорідний вигляд додатків на різних платформах.
     Для створення складних інтерфейсів користувача за допомогою обмежень використовуємо пакет constraintlayout, який дозволяє створювати гнучкі та адаптивні макети інтерфейсу, що автоматично пристосовуються до різних розмірів екранів та пристроїв. 
     Використовуємо бібліотеку retrofit для здійснення HTTP-запитів. Він спрощує роботу з мережевими запитами, забезпечуючи високий рівень абстракції та підтримку різних форматів обміну даними.
     Для здійснення мережевих запитів використовується HTTP клієнт okhttp, що надає швидкий та ефективний спосіб взаємодії з вебслужбами через HTTP-запити. 
     На рисунку 4.7 зображено діаграму пакетів для візуалізації використаних пакетів. 

Рисунок 4.7 – Діаграма пакетів для мобільної частини системи «PerformMentor»
     
     Розроблено мобільну частину за допомогою Clean Architecture, яка дозволяє розділити відповідальність між різними частинами застосунку та зробити його зрозумілим, масштабованим і тестованим.
     На рисунку 4.8 можна переглянути діаграму компонентів мобільної частини. Пакет activities містить основні екранні компоненти застосунку. Кожна активність відповідає за певний екран і взаємодію з користувачем. Прикладом є активність LoginActivity, що відповідає за вхід у профіль.

Рисунок 4.8 – Діаграма компонентів

     Пакет adapters містить адаптери для RecyclerView, що відповідають за відображення списків даних у RecyclerView. У проєкті адаптери використовуються для динамічного відображення списків винагород та робочих годин користувачів.
     Пакет models містить моделі, що представляють структуру даних, які використовуються у застосунку.
     Пакет network відповідає за налаштування та роботу з мережевими запитами. Він використовує бібліотеку Retrofit для створення HTTP-клієнта та взаємодії з сервером.
     Пакет services містить сервіси, які відповідають за різні аспекти, такі як аутентифікація користувача, обробка нагород та управління годинами роботи, спрощуючи комунікацію між клієнтом і сервером та забезпечуючи потрібні дані для функціонування застосунку.
     Пакет util містить допоміжні класи та утиліти. Наприклад, SessionManager відповідає за зберігання та отримання даних сесії користувача, або NavigationUtil, що містить методи для налаштування навігаційних компонентів.
     Презентаційний шар включає activities та adapters. Тут відбувається взаємодія з користувачем та відображення даних. 
     Доменний шар містить бізнес-логіку застосунку, яку реалізовано у services. Сервіси взаємодіють із моделями та виконують основні операції, такі як отримання списків даних та їх оновлення. 
     Шар даних відповідає за доступ до даних і включає network. Тут реалізовано мережеві запити для отримання даних з сервера. Моделі (models) також можна віднести до цього шару, оскільки вони представляють структуру даних, що надходять з мережі.
     Було розроблено діаграму станів для користувачів (див. рис. 4.9). Діаграма розроблена для відображення різних можливих станів системи, подій, які можуть призвести до переходів між цими станами, а також дій, які відбуваються у кожному з цих станів.

Рисунок 4.9 – Діаграма станів користувача
     
     Таким чином, визначили технології й архітектуру клієнтської частини програмної системи.
     Приклад кодової частини наведено у додатку Е.
     

5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
     5.1 Виклик і завантаження
     
     
     Для запуску сервера та вебзастосунка достатньо завантажити середовище розробки WebStorm з офіційного сайту. При відкритті папки «apzkr-pzpi-21-1-almakadma-mariam\Task1-Server\performmentor» треба запустити команду «node server.js» для запуску сервера. Для запуску вебчастини треба відкрити папку «apzkr-pzpi-21-1-almakadma-mariam\Task3-WebClient\performMentor_web» та запустити команду npm start. Для запуску мобільного застосунку треба завантажити середовище Android Studio з офіційного сайту, відкрити проєкт «apzkr-pzpi-21-1-almakadma-mariam\Task4-MobileClient\performMenor_mobile» та запусти натиснувши кнопку побудувати.
     
     
     5.2 Призначення і логічна структура
     
     
     Функціональність програмної системи можна виділити в окремі логічні блоки, а саме: 
* реєстрація та вхід в профіль компанії; 
* вхід в профіль користувача;
* робота з відділом, а саме перегляд, створення та редагування;
* робота з робітниками, а саме перегляд, оновлення даних, видалення за потреби, реєстрація нового користувача;
* робота з нагородами, а саме перегляд, створення, призначення та отримання;
* робота з досягненням, а саме перегляд, призначення та отримання;
* робота із завданням, створення, призначення виконавців, перегляд, оновлення;
* робота з коментарями, а саме перегляд, додавання, видалення;
* робота з годинами, наприклад, реєстрація тривалості робочого дня.
     
     
     5.3 Опис програмної реалізації
     
     
     Розглянемо клієнтську частину системи. При відкритті можемо побачити сторінку входу для компанії, у правому верхньому кутку є кнопки для вибору мови інтерфейсу: англійська та українська (див. рис. 5.1).


Рисунок 5.1 – Сторінка авторизації компанії

     Якщо треба створити профіль, то треба натиснути посилання реєстрація компанії та відкриється форма (див. рис. 5.2). 
     Після введення даних, відбувається перехід на сторінку авторизації. Після успішного входу в профіль, можна побачити інформацію про компанію, редагувати її, нижче є форма для налаштування годин та днів роботи компанії (див. рис. 5.3).

Рисунок 5.2 – Сторінка реєстрація компанії
     

Рисунок 5.3 – Сторінка налаштування профілю

     На боковій панелі є вкладка керівники та працівники, якщо відкрити її, можна побачити поле для пошуку за прізвищем, фільтрація за відділом, кнопка створити нового працівника, та список робітників. Інформацію, а саме ім’я, прізвище, відділ в якому працює можна змінювати, а також змінити посаду на керівника або працівника (див. рис. 5.4).
     На сторінці відділ користувач може обрати додати новий відділ тоді відкриється форма для додавання нового відділу, нижче можна переглянути інформацію, щодо усіх відділів (див. рис. 5.5). 

Рисунок 5.4 – Сторінка працівники та керівники


Рисунок 5.5 – Сторінка відділ
     
     На сторінці звіт, можна переглянути кругову діаграму, що відображає кількість завдань та їх статуси (див. рис. 5.6).
     На сторінці нагороди, компанія може створити нагороду та переглянути інформацію щодо працівників та їх нагород (див. рис. 5.7).

Рисунок 5.6 – Сторінка звіт
     

Рисунок 5.7 – Сторінка нагороди
     
     Розглянемо авторизацію працівника або керівника, сторінка входу в профіль (див. рис. 5.8). Функціонал працівника не такий розширений як, наприклад у керівника. Працівник може переглянути свій профіль, досягнення, оновити пароль (див. рис. 5.9). Також може переглянути свої нагороди та забрати їх, якщо цього ще не було зроблено (див. рис. 5.10). 

Рисунок 5.8 – Сторінка авторизації керівника або працівника
     

Рисунок 5.9 – Сторінка профіль працівника


Рисунок 5.10 – Сторінка мої нагороди
     Можемо переглянути, оновити завдання, що були назначені, переглянути виконавців, переглянути, додати та видалити коментарі  (див. рис. 5.11).

Рисунок 5.11 – Сторінка назначені завдання
     
     На цьому функціонал працівника завершено, але у керівника є більше можливостей. Керівник може переглядати працівників відділу та призначати їм бонуси. Наприклад, досягнення, де треба вказати заголовок, опис, кількість нарахованих балів (див. рис. 5.12). Нижче можемо побачити кнопки для призначення нагород. Їх призначають за якісь внески у роботи, але стягують бали з балансу користувача.

Рисунок 5.12 – Сторінка працівники та керівники відділу
     На сторінці всі завдання відділу керівник може створити нове завдання, обрати користувачів, які будуть виконувати завдання. Керівник може оновлювати завдання, переглядати, додавати та видаляти коментарі (див. рис. 5.13).

Рисунок 5.13 – Сторінка всі завдання відділу
     
     На цьому функціонал вебзастосунка завершено. Перейдемо до мобільного застосунку.
     Мобільний застосунок призначений для керівників або працівників. Функціонал для всіх однаковий. На сторінці авторизації користувач може обрати мову інтерфейсу для подальшого використання у застосунку (див. рис. 5.14).
     
     Рисунок 5.14 – Сторінка авторизації користувача
     Після успішного входу в профіль, користувач бачить сторінку, де відображено нагороди та кнопка забрати, якщо цього не було зроблено (див. рис. 5.15). Розглянемо сторінку години роботи (див рис. 5.16).
     
     Рисунок 5.15 – Сторінка нагороди
     
      
     Рисунок 5.16 – Сторінка години роботи
     
     На сторінці години роботи, користувач може відзначити початок, кінець роботи та перерви. А також переглянути інформацію про свою тривалість робочого дня відповідно до дня. Опис функціонала завершено.
ВИСНОВКИ
     
     
     Під час курсового проєктування було розроблено програмну систему для контролю ефективності роботи працівників на підприємстві. 
     Перед початком розробки системи, було проаналізовано предметну область та аналоги, що існують в області контролю роботи, спроєктовано базу даних, було розроблено архітектуру для серверної частини, вебчастини та мобільної частини. Використано такі технології та мови програмування як: Express.js, node.js, React, JavaScript, TypeScript, Kotlin.
     За допомогою системи компанії можуть структурувати та контролювати робочі кадри, переглядати прогрес виконання завдань, а також заохочувати працівників за допомогою системи бонусів.
     Працівники окрім виконання назначених завдань та співпраці з іншими користувачами, можуть викупати нагороди та отримувати досягнення, що позитивно впливає на мотивацію та продуктивність користувачів на підприємстві. 
     
     
     

     
     
     
     
     
     
     
     
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


     1. PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/16/index.html (дата звернення: 08.06.2024).
     2. Express documentation. URL: https://devdocs.io/express/ (дата звернення: 08.06.2024).
     3. Introducting react.dev. URL: https://react.dev/blog/2023/03/16/introducing-react-dev (дата звернення: 08.06.2024).
     4. Посилання на відео із захистом курсової роботи:
     5. Посилання на код системи, що була розроблена:
https://github.com/NureAlmakadmaMariam/apzkr-pzpi-21-1-almakadma-mariam.git
     














ДОДАТОК А
Результати перевірки щодо академічної доброчесності 




ДОДАТОК Б
Діаграма станів

     

Рисунок Б.1 – Діаграма станів компанії


Рисунок Б.2 – Діаграма станів керівника

Рисунок Б.3 – Діаграма станів працівника
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

ДОДАТОК В
Діаграми для клієнтської частини «PerformMentor»
     
     

Рисунок В.1 – Діаграма прецедентів для системи з актором «компанія»


Рисунок В.2 – Діаграма прецедентів для системи з актором «керівник»

Рисунок В.3 – Діаграма прецедентів для системи з актором «працівник»
     

Рисунок В.4 – Діаграма компонентів
     


Рисунок В.5 – Діаграма взаємодії акторів «керівник» та «працівник»


Рисунок В.6 – Діаграма взаємодії актора «компанія»
ДОДАТОК Г
Програмний код серверної частини «PerformMentor»
     Г.1 Частина коду головного файла для роботи сервера server.js


     1 const { express, router, pool } = require('./configuration/commonConfig');
     2 const bodyParser = require('body-parser'); 
     3 const app = express();
     4 // Middleware
     5 app.use(bodyParser.json());
     6 app.use('/backup', backupRouter);
     7 // Routes
     8 app.use('/company', companyRoutes);
     9 app.use('/department', departmentRoutes);
     10 app.use('/users', userRoutes);
     11 app.use('/task', taskRoutes);
     12 app.use('/taskExecutor', taskExecutorRoutes);
     13 app.use('/comment', commentRoutes);
     14 app.use('/wHS', workHoursSettingsRouter);
     15 app.use('/workH', workHoursRouter);
     16 app.use('/achievements', achievementRouter);
     17 app.use('/reward', rewardRouter);
     18 app.use('/users-reward', usersRewardRouter);
     19 app.use('/report', reportRouter);
     20 app.use((req, res, next) => {
     21 	res.setHeader('Access-Control-Allow-Origin', '*');
     22	res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
     23	res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
     24   next();
     25 });
     26 // Call initializeAssociations function after initializing Sequelize
     27 const initializeAssociations = require('./models/association');
     28 initializeAssociations();
     29 const PORT = 3500;
     30 app.listen(PORT, () => {
     31.     console.log(`Server is running on port ${PORT}`); })
     Г.2 Код для визначення асоціації з файлу association.js
      
     
     1 const initializeAssociations = () => {
     2     Task.belongsTo(User, { foreignKey: 'user_id', as: 'taskOwner' });
     3     User.hasMany(Task, { foreignKey: 'user_id', as: 'tasks' });
     4     Task.belongsToMany(User, { through: TaskExecutor, foreignKey: 'task_id', as: 'executors' });
     5     User.belongsToMany(Task, { through: TaskExecutor, foreignKey: 'executor_id', as: 'assignedTasks' });
     6     TaskExecutor.belongsTo(User, { foreignKey: 'executor_id', as: 'executor' });
     7     User.belongsTo(Department, { foreignKey: 'department_id', as: 'department' });
     8     Department.hasMany(User, { foreignKey: 'department_id', as: 'user' });
     9     Department.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });
     10    Company.hasMany(Department, { foreignKey: 'company_id', as: 'departments' });
     11    Comment.belongsTo(Task, { foreignKey: 'task_id', as: 'task' });
     12    Comment.belongsTo(User, { foreignKey: 'user_id', as: 'user' });
     13    Company.hasMany(WorkHoursSettings, { foreignKey: 'company_id', as: 'workHoursSettings' });
     14    WorkHoursSettings.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });
     15    User.hasMany(WorkHours, { foreignKey: 'user_id', as: 'workHours' });
     16    WorkHours.belongsTo(User, { foreignKey: 'user_id', as: 'user' });
     17    User.hasMany(Achievement, { foreignKey: 'user_id', as: 'achievements' });
     18    Achievement.belongsTo(User, { foreignKey: 'user_id', as: 'user' });
     19    Reward.belongsTo(Company, { foreignKey: 'company_id', as: 'company' });
     20    Company.hasMany(Reward, { foreignKey: 'company_id', as: 'rewards' });
     21    UsersReward.belongsTo(Reward, { foreignKey: 'reward_id', as: 'reward' });
     22    Reward.hasMany(UsersReward, { foreignKey: 'reward_id', as: 'usersRewards' });
     23    UsersReward.belongsTo(User, { foreignKey: 'user_id', as: 'user' });
     24 };
     25
     26 module.exports = initializeAssociations;
      
      
     Г.3 Модель для компанії з файлу companyModel.js
      
      
     1 // companyModel.js
     2 const { DataTypes } = require('sequelize');
     3 const sequelize = require('../configuration/dbConfig');
     4 const bcrypt = require('bcrypt');
     5 const Company = sequelize.define('Company', {
     6     company_id: {
     7         type: DataTypes.BIGINT,
     8         primaryKey: true,
     9         autoIncrement: true,
     10     },
     11     name: {
     12         type: DataTypes.STRING(255),
     13         allowNull: false, 
     14     },
     15     email: {
     16         type: DataTypes.STRING(255),
     17         allowNull: true, 
     18         unique: true,
     19         validate: {
     20             isEmail: true, // Перевірка формату емейлу
     21         },
     22     },
     23     password: {
     24         type: DataTypes.STRING(255),
     25         allowNull: false, /
     26         set(value) {
     27             // Хешування пароля перед збереженням в базу даних
     28             const hashedPassword = bcrypt.hashSync(value, 10);
     29             this.setDataValue('password', hashedPassword);
     30         },
     31     },
     32     address: {
     33         type: DataTypes.TEXT,
     34         allowNull: true, /*false*/
     35     },
     36     created_at: {
     37         type: DataTypes.DATEONLY,
     38         allowNull: true, 
     39         defaultValue: DataTypes.NOW,
     40     },
     41 }, {
     42     tableName: 'company',
     43     timestamps: false, 
     44 });
     45 module.exports = Company
      
      
     Г.4 Код для обробки робочого часу та розрахунку понаднормової роботи у файлі workHoursService.js 
      
     
     1 // workHoursService.js
     2 
     3 exports.endWork = async (userId) => {
     4     const workHour = await WorkHours.findOne({ where: { user_id: userId, date: new Date() } });
     5     if (!workHour) {
     6         throw new Error('Work hour not found');
     7     }
     8 
     9     if (workHour.end_time) {
     10        throw new Error('Work period has already ended');
     11    }
     12 
     13    if (!workHour.start_time) {
     14        throw new Error('Start time not set');
     15    }
     16 
     17    const currentTime = new Date().toLocaleTimeString('en-US', { hour12: false, timeZone: 'Europe/Copenhagen' });
     18    workHour.end_time = currentTime;
     19 
     20    const startTime = new Date(`${workHour.date} ${workHour.start_time}`);
     21    const endTime = new Date();
     22    const totalWorkDurationMilliseconds = endTime - startTime;
     23    const totalWorkDurationMinutes = Math.floor(totalWorkDurationMilliseconds / (1000 * 60));
     24 
     25    if (workHour.break_start_time && workHour.break_end_time) {
     26        const breakStartTime = new Date(`${workHour.date} ${workHour.break_start_time}`);
     27        const breakEndTime = new Date(`${workHour.date} ${workHour.break_end_time}`);
     28        const breakDurationMilliseconds = breakEndTime - breakStartTime;
     29        const breakDurationMinutes = Math.floor(breakDurationMilliseconds / (1000 * 60));
     30 
     31        workHour.total_break_duration_minutes = breakDurationMinutes;
     32        workHour.total_work_duration_minutes = totalWorkDurationMinutes - breakDurationMinutes;
     33    } else {
     34        workHour.total_work_duration_minutes = totalWorkDurationMinutes;
     35    }
     36 
     37    const user = await User.findByPk(workHour.user_id, { include: { association: 'department' } });
     38    if (!user) {
     39        throw new Error('User not found');
     40    }
     41 
     42    const companyId = user?.department?.company_id;
     43    if (!companyId) {
     44        throw new Error('Company ID not found for the user');
     45    }
     46 
     47    const workHoursSettings = await WorkHoursSettings.findOne({ where: { company_id: companyId } });
     48    if (!workHoursSettings) {
     49        throw new Error('Work hours settings not found');
     50    }
     51 
     52    const { hours_per_day } = workHoursSettings;
     53    if (!hours_per_day) {
     54        throw new Error('Hours per day not set in work hours settings');
     55    }
     56 
     57    const overtimeMinutes = totalWorkDurationMinutes - (hours_per_day * 60);
     58    workHour.total_overtime_minutes = Math.max(overtimeMinutes, 0);
     59 
     60    await workHour.save();
     61    return workHour;
     62 };
      
      
     Г.5 Код для автоматичного створення користувача у файлі userController.js 
      
     
     1 const User = require('../models/userModel');
     2 const Department = require('../models/departmentModel');
     3 const Status = require('../models/statusModel');
     4 const Company = require('../models/companyModel');
     5 
     6 const bcrypt = require('bcrypt');
     7 const transliteration = require('transliteration');
     8 exports.createUser = async (req, res) => {
     9     try {
     10.         const { first_name, last_name, department_id, start_date } = req.body;
     11 
     12         const latinFirstName = transliteration.transliterate(first_name);
     13         const latinLastName = transliteration.transliterate(last_name);
     14 
     15         const generatedEmail = `${latinFirstName.toLowerCase()}.${latinLastName.toLowerCase()}@example.com`;
     16 
     17         const generatedPassword = Math.random().toString(36).slice(-8); // Generates an 8-character random alphanumeric password
     18 
     19         const hashedPassword = await bcrypt.hash(generatedPassword, 10);
     20 
     21         const newUser = await User.create({
     22             first_name,
     23             last_name,
     24             email: generatedEmail,
     25             password: hashedPassword,
     26             department_id,
     27             start_date
     28         });
     29 
     30         res.status(201).json({
     31             message: 'User created successfully',
     32             newUser,
     33             generatedPassword,
     34             generatedEmail
     35         });
     36     } catch (error) {
     37         res.status(500).json({ error: 'Internal Server Error' });
     38     }
     39 };
     
     
     Г.6 Код створення звіту щодо статусу завдання у файлі ReportService.js
     
     
     1 // ReportService.js
     2 const { getUsersByCompany } = require('./UserService');
     3 const sequelize = require('../configuration/dbConfig');
     4 const Task = require('../models/taskModel');
     5 
     6 exports.getTaskStatusReport = async (companyId) => {
     7     const users = await getUsersByCompany(companyId);
     8     const userIds = users.map(user => user.user_id);
     9 
     10    const taskReport = await Task.findAll({
     11        where: { user_id: userIds },
     12        attributes: ['status', [sequelize.fn('COUNT', 'status'), 'count']],
     13        group: ['status']
     14    });
     15 
     16    const totalCount = taskReport.reduce((total, task) => total + parseInt(task.get('count'), 10), 0);
     17 
     18    const reportWithPercentage = taskReport.map(task => ({
     19        status: task.status,
     20        count: task.get('count'),
     21        percentage: ((parseInt(task.get('count'), 10) / totalCount) * 100).toFixed(2)
     22    }));
     23 
     24    return reportWithPercentage;
     25 }; 
     
     
     
     
     
     
     
     
     
     
     
     
     
     
ДОДАТОК Д
Програмний код клієнтської частини «PerformMentor»
     Д.1 Код з файлу AuthContext.tsx

     
     1 // src/context/AuthContext.tsx
     2 import React, { createContext, useState, ReactNode, useEffect } from 'react';
     3 import { loginCompany as loginCompanyService, loginUser as loginUserService } from '../features/auth';
     4 import { AuthResponse } from '../interfaces/AuthResponse';
     5 
     6 interface AuthContextType {
     7     authState: AuthState;
     8     loginCompany: (email: string, password: string) => Promise<void>;
     9     loginUser: (email: string, password: string) => Promise<void>;
     10     logout: () => void;
     11 }
     12 
     13 interface AuthState {
     14     companyId: number | null;
     15     user_id: number | null;
     16     role: 'employee' | 'manager' | null;
     17     department_id: number | null;
     18 }
     19 
     20 export const AuthContext = createContext<AuthContextType | undefined>(undefined);
     21 
     22 export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
     23     const [authState, setAuthState] = useState<AuthState>({
     24         companyId: null,
     25         user_id: null,
     26         role: null,
     27         department_id: null,
     28     });
     29 
     30     useEffect(() => {
     31         const storedCompanyId = localStorage.getItem('companyId');
     32         const storedUserData = localStorage.getItem('user');
     33         if (storedCompanyId) {
     34             setAuthState(prevState => ({
     35                 ...prevState,
     36                 companyId: Number(storedCompanyId),
     37             }));
     38         }
     39         if (storedUserData) {
     40             const userData: AuthState = JSON.parse(storedUserData);
     41             setAuthState(prevState => ({
     42                 ...prevState,
     43                 user_id: userData.user_id,
     44                 role: userData.role,
     45                 department_id: userData.department_id,
     46             }));
     47         }
     48     }, []);
     49 
     50     const loginCompany = async (email: string, password: string) => {
     51         try {
     52             const data: AuthResponse = await loginCompanyService(email, password);
     53             localStorage.setItem('companyId', String(data.companyId));
     54             setAuthState({
     55                 companyId: data.companyId || null,
     56                 user_id: null,
     57                 role: null,
     58                 department_id: null,
     59             });
     60         } catch (error) {
     61             console.error('Login error:', error);
     62             throw error;
     63         }
     64     };
     65 
     66     const loginUser = async (email: string, password: string) => {
     67         try {
     68             const data: AuthResponse = await loginUserService(email, password);
     69             localStorage.setItem('user', JSON.stringify(data));
     70             setAuthState({
     71                 companyId: null,
     72                 user_id: data.user_id || null,
     73                 role: data.role || null,
     74                 department_id: data.department_id || null,
     75             });
     76             console.log("Department ID:", data.department_id);
     77             console.log("User ID:", data.user_id);
     78         } catch (error) {
     79             console.error('Login error:', error);
     80             throw error;
     81         }
     82     };
     83     const logout = () => {
     84         setAuthState({
     85             companyId: null,
     86             user_id: null,
     87             role: null,
     88             department_id: null,
     89         });
     90         localStorage.removeItem('companyId');
     91         localStorage.removeItem('user');
     92     };
     93 
     94     return (
     95         <AuthContext.Provider value={{ authState, loginCompany, loginUser, logout }}>
     96             {children}
     97         </AuthContext.Provider>
     98     );
     99 };
     
     
     Д.2 Код з файлу AppRouter.tsx, де прописано маршрути до сторінок
     
     
     1 // src/app/router/AppRouter.tsx
     2 export const AppRouter: React.FC = () => {
     3     return (
     4         <Router>
     5             <Routes>
     6                 <Route path="/" element={<Navigate to="/login" replace />} />
     7                 <Route path="/login" element={<LoginPage />} />
     8                 <Route path="/registration" element={<RegistrationPage />} />
     9                 <Route path="/company-settings" element={<CompanySettingsPage />} />
     10                <Route path="/company-users" element={<CompanyUsersPage />} />
     11                <Route path="/company-department" element={<DepartmentsPage />} />
     12                <Route path="/task-status-report" element={<TaskStatusReportPage />} />
     13                <Route path="/company-reward" element={<RewardsPage />} />
     14                <Route path="/login-user" element={<UserLoginPage />} />
     15                <Route path="/user-profile" element={<UserProfilePage />} />
     16                <Route path="/manager-department" element={<UsersByDepartmentPage />} />
     17                <Route path="/user-reward" element={<UserRewardsPage />} />
     18                <Route path="/user-task" element={<UserTasksPage />} />
     19                <Route path="/manager-task" element={<TasksByDepartmentPage />} />
     20            </Routes>
     21        </Router>
     22    );
     23 }
     
     
     Д.3 Код з файлу TaskStatusChart.tsx, де описано відображення кругової діаграми
     
     
     1  import React from 'react';
     2  import { Pie } from 'react-chartjs-2';
     3  import { Chart as ChartJS, ArcElement, Tooltip, Legend } from 'chart.js';
     4  import { TaskStatusReport } from '../../interfaces/Report';
     5  import { FormattedMessage, useIntl } from 'react-intl';
     6  import styles from '../../styles/TaskStatusReportPage.module.css';
     7  
     8  ChartJS.register(ArcElement, Tooltip, Legend);
     9  
     10 interface TaskStatusChartProps {
     11     data: TaskStatusReport[];
     12 }
     13 
     14 const TaskStatusChart: React.FC<TaskStatusChartProps> = ({ data }) => {
     15     const intl = useIntl();
     16 
     17     const translateStatus = (status: string): string => {
     18         return intl.formatMessage({ id: `taskStatus.${status}` });
     19     };
     20 
     21     const chartData = {
     22         labels: data.map(item => translateStatus(item.status)),
     23         datasets: [
     24             {
     25                 label: 'Task Status',
     26                 data: data.map(item => item.count),
     27                 backgroundColor: [
     28                     'rgba(255, 99, 132, 0.2)',
     29                     'rgba(54, 162, 235, 0.2)',
     30                     'rgba(255, 206, 86, 0.2)',
     31                     'rgba(75, 192, 192, 0.2)',
     32                     'rgba(153, 102, 255, 0.2)',
     33                     'rgba(255, 159, 64, 0.2)'
     34                 ],
     35                 borderColor: [
     36                     'rgba(255, 99, 132, 1)',
     37                     'rgba(54, 162, 235, 1)',
     38                     'rgba(255, 206, 86, 1)',
     39                     'rgba(75, 192, 192, 1)',
     40                     'rgba(153, 102, 255, 1)',
     41                     'rgba(255, 159, 64, 1)'
     42                 ],
     43                 borderWidth: 1
     44             }
     45         ]
     46     };
     47 
     48     const chartOptions = {
     49         plugins: {
     50             legend: {
     51                 display: false
     52             }
     53         }
     54     };
     55 
     56     return (
     57         <div className={styles.chartContainer}>
     58             <Pie data={chartData} options={chartOptions} />
     59             <div className={styles.customLegend}>
     60                 {data.map((item, index) => (
     61                     <div key={index} className={styles.legendItem}>
     62                         <span
     63                             className={styles.legendColorBox}
     64                             style={{ backgroundColor: chartData.datasets[0].backgroundColor[index] }}
     65                         ></span>
     66                         <span>
     67                             <FormattedMessage id={`taskStatus.${item.status}`} />: {item.count} = {item.percentage}%
     68                         </span>
     69                     </div>
     70                 ))}
     71             </div>
     72         </div>
     73     );
     74 };
     75 
     76 export default TaskStatusChart;
     
     
ДОДАТОК Е
Програмний код мобільної частини «PerformMentor»
     Е.1 Код з файлу WorkHoursActivity.kt
     
     
     1  // activities/WorkHoursActivity.kt
     2  
     3  class WorkHoursActivity : AppCompatActivity() {
     4      private val workHoursService = RetrofitInstance.retrofit.create(WorkHoursService::class.java)
     5      private lateinit var sessionManager: SessionManager
     6  
     7      private lateinit var recyclerViewWorkHours: RecyclerView
     8      private lateinit var workHoursAdapter: WorkHoursAdapter
     9      private val workHoursList = mutableListOf<WorkHours>()
     10 
     11     override fun onCreate(savedInstanceState: Bundle?) {
     12         super.onCreate(savedInstanceState)
     13         setContentView(R.layout.activity_work_hours)
     14 
     15         sessionManager = SessionManager(this)
     16 
     17         setupBottomNavigationView()
     18         setupButtons()
     19         setupRecyclerView()
     20 
     21         fetchWorkHours()
     22     }
     23 
     24     private fun setupBottomNavigationView() {
     25         val bottomNavigationView = findViewById<BottomNavigationView>(R.id.bottomNavigationView)
     26         bottomNavigationView.selectedItemId = R.id.work_hours
     27         bottomNavigationView.setOnNavigationItemSelectedListener { item ->
     28             NavigationUtil.handleBottomNavigation(this, item.itemId)
     29             true
     30         }
     31     }
     32 
     33     private fun setupButtons() {
     34         findViewById<Button>(R.id.btnStartWork).setOnClickListener { onStartWorkClicked() }
     35         findViewById<Button>(R.id.btnStartBreak).setOnClickListener { onStartBreakClicked() }
     36         findViewById<Button>(R.id.btnEndBreak).setOnClickListener { onEndBreakClicked() }
     37         findViewById<Button>(R.id.btnEndWork).setOnClickListener { onEndWorkClicked() }
     38     }
     39 
     40     private fun setupRecyclerView() {
     41         recyclerViewWorkHours = findViewById(R.id.recyclerViewWorkHours)
     42         workHoursAdapter = WorkHoursAdapter(workHoursList)
     43         recyclerViewWorkHours.layoutManager = LinearLayoutManager(this)
     44         recyclerViewWorkHours.adapter = workHoursAdapter
     45     }
     46 
     47     private fun fetchWorkHours() {
     48         val userId = sessionManager.getUserId()
     49         if (userId != null) {
     50             GlobalScope.launch(Dispatchers.Main) {
     51                 val response = workHoursService.getAllByUser(userId.toLong())
     52                 if (response.isSuccessful) {
     53                     val fetchedWorkHoursList = response.body()
     54                     if (fetchedWorkHoursList != null && fetchedWorkHoursList.isNotEmpty()) {
     55                         workHoursList.clear()
     56                         workHoursList.addAll(fetchedWorkHoursList)
     57                         workHoursAdapter.notifyDataSetChanged()
     58                     }
     59                 } else {
     60                     showToast(getString(R.string.failed_to_fetch_work_hours))
     61                 }
     62             }
     63         } else {
     64             showToast(getString(R.string.user_id_not_found))
     65         }
     66     }
     67 
     68     private fun onStartWorkClicked() {
     69         val userId = sessionManager.getUserId()
     70         if (userId != null) {
     71             GlobalScope.launch(Dispatchers.Main) {
     72                 val response = workHoursService.startWork(UserIdRequest(userId.toLong()))
     73                 if (response.isSuccessful) {
     74                     showToast(getString(R.string.work_started_successfully))
     75                     fetchWorkHours()
     76                 } else {
     77                     showToast(getString(R.string.failed_to_start_work))
     78                 }
     79             }
     80         } else {
     81             showToast(getString(R.string.user_id_not_found))
     82         }
     83     }
     84 
     85     private fun onStartBreakClicked() {
     86         val userId = sessionManager.getUserId()
     87         if (userId != null) {
     88             GlobalScope.launch(Dispatchers.Main) {
     89                 val response = workHoursService.startBreak(UserIdRequest(userId.toLong()))
     90                 if (response.isSuccessful) {
     91                     showToast(getString(R.string.break_started_successfully))
     92                     fetchWorkHours()
     93                 } else {
     94                     showToast(getString(R.string.failed_to_start_break))
     95                 }
     96             }
     97         } else {
     98             showToast(getString(R.string.user_id_not_found))
     99         }
     100    }
     101 
     102    private fun onEndBreakClicked() {
     103        val userId = sessionManager.getUserId()
     104        if (userId != null) {
     105            GlobalScope.launch(Dispatchers.Main) {
     106                val response = workHoursService.endBreak(UserIdRequest(userId.toLong()))
     107                if (response.isSuccessful) {
     108                    showToast(getString(R.string.break_ended_successfully))
     109                    fetchWorkHours()
     110                } else {
     111                    showToast(getString(R.string.failed_to_end_break))
     112                }
     113            }
     114        } else {
     115            showToast(getString(R.string.user_id_not_found))
     116        }
     117    }
     118 
     119    private fun onEndWorkClicked() {
     120        val userId = sessionManager.getUserId()
     121        if (userId != null) {
     122            GlobalScope.launch(Dispatchers.Main) {
     123                val response = workHoursService.endWork(UserIdRequest(userId.toLong()))
     124                if (response.isSuccessful) {
     125                    showToast(getString(R.string.work_ended_successfully))
     126                    fetchWorkHours()
     127                } else {
     128                    showToast(getString(R.string.failed_to_end_work))
     129                }
     130            }
     131        } else {
     132            showToast(getString(R.string.user_id_not_found))
     133        }
     134    }
     135 
     136    private fun showToast(message: String) {
     137        Toast.makeText(this@WorkHoursActivity, message, Toast.LENGTH_SHORT).show()
     138    }
     139 }
     
     
     Е.2 Код з файлу WorkHoursAdapter.kt
     
     
     1  //adapters/WorkHoursAdapter.kt
     2  class WorkHoursAdapter(private val workHoursList: List<WorkHours>) : RecyclerView.Adapter<WorkHoursAdapter.WorkHoursViewHolder>() {
     3  
     4      class WorkHoursViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
     5          val tvWorkDate: TextView = itemView.findViewById(R.id.tvWorkDate)
     6          val tvStartTime: TextView = itemView.findViewById(R.id.tvStartTime)
     7          val tvBreakStartTime: TextView = itemView.findViewById(R.id.tvBreakStartTime)
     8          val tvBreakEndTime: TextView = itemView.findViewById(R.id.tvBreakEndTime)
     9          val tvEndTime: TextView = itemView.findViewById(R.id.tvEndTime)
     10         val tvTotalWorkDuration: TextView = itemView.findViewById(R.id.tvTotalWorkDuration)
     11         val tvTotalBreakDuration: TextView = itemView.findViewById(R.id.tvTotalBreakDuration)
     12     }
     13 
     14     override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): WorkHoursViewHolder {
     15         val itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_work_hours, parent, false)
     16         return WorkHoursViewHolder(itemView)
     17     }
     18 
     19     override fun onBindViewHolder(holder: WorkHoursViewHolder, position: Int) {
     20         val currentWorkHours = workHoursList[position]
     21         holder.tvWorkDate.text = currentWorkHours.date
     22         holder.tvStartTime.text = currentWorkHours.start_time ?: "N/A"
     23         holder.tvBreakStartTime.text = currentWorkHours.break_start_time ?: "N/A"
     24         holder.tvBreakEndTime.text = currentWorkHours.break_end_time ?: "N/A"
     25         holder.tvEndTime.text = currentWorkHours.end_time ?: "N/A"
     26         holder.tvTotalWorkDuration.text = currentWorkHours.total_work_duration_minutes?.toString() ?: "N/A"
     27         holder.tvTotalBreakDuration.text = currentWorkHours.total_break_duration_minutes?.toString() ?: "N/A"
     28     }
     29 
     30     override fun getItemCount() = workHoursList.size
     31 }
      33
      
